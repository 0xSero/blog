---
title: 'AI-Assisted Coding: My Experience'
date: '2024-12-23'
tags: ['AI', 'Developer Tools', 'Productivity', 'Cursor', 'Claude']
draft: false
summary: 'Months of optimizing my workflow with Cursor and Claude Code. The techniques that actually multiply productivity.'
---

AI-assisted coding has fundamentally transformed how I build software. After spending months deeply exploring and optimizing my workflow with tools like Cursor IDE and Claude Code, I've compiled the essential techniques that have multiplied my productivity while preserving my fundamental coding skills.

## The Context Window Game-Changer

Understanding context windows is crucial for maximizing AI coding efficiency.

Cursor's implementation of Claude 3.7 Sonnet offers approximately 48K tokens in standard mode, while Max mode provides a massive 200K token context window (though at additional cost of $0.05 per prompt and per tool call).

For reference:

- A typical 200-line React component consumes about **1,500 tokens**
- A Python file of similar length requires approximately **1,700 tokens**

This means you can comfortably fit multiple files within the standard context window, but should be strategic about which files you include.

**The golden rule:** keep individual files under 400 lines whenever possible, and break larger files into modules with clear responsibilities. For more complex projects/files/objects aim for less than 1k lines.

## Smart Context Management Techniques

The single technique that transformed my Cursor workflow was learning to strategically manage context.

Close all editor tabs first, then open only the most relevant files before adding them all to context using the slash (/) menu → "Reference Open Editors". This provides the AI with precisely the information it needs without overwhelming the context window.

For large codebases, create a dedicated `/docs/ai` folder containing files that explain your:

- Architecture approach
- Coding standards
- Component patterns
- State management philosophy
- API conventions
- Testing strategy

The AI will reference these documents automatically when generating code, ensuring consistency across your entire codebase.

## The Power of .cursor/rules

One of Cursor's most underutilized features is the `.cursor/rules` file, which provides specific project rules that Cursor AI will follow when generating code. This is incredibly powerful for maintaining consistency.

Here's an example `.cursor/rules` file I use for React projects:

```
UI and Styling:
- Use Shadcn UI and Tailwind for components and styling
- Implement mobile-first responsive design
- Prefer function components over class components
- Use CSS modules for component-specific styles

Performance:
- Minimize 'use client' directives
- Favor React Server Components
- Wrap client components in Suspense with fallback
- Use dynamic loading for non-critical components
- Optimize images with next/image

Architecture:
- Use the repository pattern for data access
- Implement clean architecture with clear separation of concerns
- Keep components under 150 lines
- Extract complex logic to custom hooks
```

This ensures the AI consistently applies your preferred patterns and best practices without you having to repeat the same instructions.

## @Docs Feature

Cursor's @Docs feature is a game-changer for maintaining flow and improving AI code quality. This powerful capability lets you integrate external documentation directly into your AI interactions without constant context switching.

The process is simple: provide a documentation link, Cursor indexes it, and you can reference it by typing @Doc or the document's name in your prompts. This keeps you focused on coding rather than tab-switching for reference material.

### Quick Setup Guide

1. **Add documentation:** Type @ in Chat or Composer, select "Docs," enter a URL, and give it a name (e.g., "TensorFlow").

2. **Use in prompts:** Reference documentation with @Name syntax: "Implement a custom loss function using @TensorFlow documentation."

3. **Manage sources:** Find all documentation under Settings > Features > Docs. Cursor automatically re-indexes these periodically as they change.

Cursor includes built-in documentation for many popular libraries and frameworks accessible via @LibraryName (like @React or @Python). You can extend this with specialized libraries, version-specific docs, or internal API documentation.

## Unlocking Agent Mode

Cursor's Agent mode (accessible via `cmd + I` or using the dropdown) is its most powerful feature. It continuously calls Claude until the goal has been achieved, searching files, gathering more context, running tests, and installing packages as needed.

For maximum efficiency:

- Enable "Yolo mode" in settings to allow Cursor to run tests without asking for confirmation
- Create a new agent window periodically as longer conversations can cause Claude to forget earlier instructions
- Use specific phrases like "think hard" to trigger extended thinking for complex problems

## Claude Code: Command Line Mastery

Claude Code provides similar capabilities but in a command-line environment. It operates directly in your terminal, understanding your project context and taking real actions with no need to manually add files to context.

A great trick I've found is using graduated "thinking" triggers. Each level allocates progressively more thinking budget, allowing Claude to evaluate alternatives more thoroughly before taking action.

For long sessions, use the `/clear` command frequently between tasks to reset the context window, which can become cluttered with irrelevant conversation, file contents, and commands.

## AI-Optimized Architecture Patterns

Certain architectural patterns work exceptionally well with AI coding assistants:

**Reflection Pattern:** Have the AI generate a solution, then review and critique its own code, refining it based on its self-evaluation.

**Tool Use Pattern:** Enable the AI to interact with external tools and resources, accessing databases, performing web searches, or executing functions.

**Planning Pattern:** Before implementation, have the AI create a detailed plan, then provide feedback before it proceeds with coding.

**Multiagent Pattern:** Use "subagents" to verify details or investigate particular questions while preserving main context.

These patterns enable more autonomous, efficient AI coding assistance that produces higher quality results.

## Test-Driven Development with AI

AI coding assistants excel at generating tests, making TDD particularly effective:

1. Have the AI generate test cases for your feature
2. Implement the tests
3. Ask the AI to write code that passes the tests
4. Integrate the code and run the tests
5. Get the AI to fix any failing tests
6. Finalize the implementation

Claude Code is especially effective for test-driven development, debugging complex issues, and large-scale refactoring.

## Project Structure Optimization

Organizing your project files to maximize AI comprehension pays enormous dividends:

- Include your PRD (Product Requirements Document) as a Markdown file in your repository
- Use clear, descriptive file and directory names
- Keep related files close together in the directory structure
- Use `.cursorignore` to skip large files the AI should ignore

## Preserving Your Coding Skills

Using AI tools extensively raises valid concerns about skill atrophy. Here's my balanced approach:

**Schedule manual coding sessions:** Set aside dedicated time for coding without AI assistance, focusing on algorithms, data structures, and system design.

**Implement core functionality manually:** Critical security, performance, and business logic should still be written by you.

**Review ALL AI-generated code:** Understand every line before accepting it, ask the AI to explain complex sections, and modify the code manually to ensure understanding.

**Regular challenges:** Periodically solve coding problems without AI assistance to maintain your skills.

**Assessment framework:** Track your progress by setting a baseline of skills, identifying areas for improvement, and creating targeted practice plans.

## Workflow Strategies by Project Type

Different project types benefit from customized AI workflows:

### Frontend Development

- Use AI to generate the project scaffold
- Let it handle boilerplate components
- Focus your manual effort on complex interactions and state management

### Backend/API Development

- Have AI generate endpoint stubs and validation
- Manually implement business logic and security
- Use AI for test coverage

### Refactoring

- Claude Code excels here—point it at legacy code and describe the target architecture
- Review changes carefully before committing

---

Still refining this workflow. The tools keep getting better, and so does the output.
