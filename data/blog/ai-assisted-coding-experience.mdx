---
title: 'AI-Assisted Coding: What Actually Works'
date: '2024-12-23'
tags: ['AI', 'Developer Tools', 'Productivity', 'Cursor', 'Claude']
draft: false
summary: 'Months of optimizing my workflow with Cursor and Claude Code. The techniques that actually multiply productivity.'
---

AI-assisted coding changed how I build software. After months optimizing my workflow with Cursor and Claude Code, here are the techniques that actually multiply productivity without turning you into a prompt monkey.

## Context Windows Matter

Understanding context windows is the difference between useful AI and garbage output.

Cursor's Claude 3.7 Sonnet gives you about 48K tokens in standard mode. Max mode bumps that to 200K (costs extra, $0.05 per prompt and tool call).

Real numbers:

- 200-line React component: ~1,500 tokens
- Python file same length: ~1,700 tokens

You can fit multiple files in standard context, but be strategic. The golden rule: keep files under 400 lines. Break larger files into modules with clear responsibilities. Complex projects, aim for under 1k lines per file.

## Smart Context Management

The technique that changed everything: strategic context management.

Close all editor tabs. Open only the relevant files. Add them to context using slash (/) menu and "Reference Open Editors". The AI gets exactly what it needs, nothing more.

For large codebases, create a `/docs/ai` folder with:

- Architecture approach
- Coding standards
- Component patterns
- State management philosophy
- API conventions
- Testing strategy

The AI references these automatically. Consistency across your entire codebase without repeating yourself.

## .cursor/rules

Underutilized feature. The `.cursor/rules` file gives project-specific instructions that Cursor follows when generating code.

Example for React projects:

```
UI and Styling:
- Use Shadcn UI and Tailwind for components and styling
- Implement mobile-first responsive design
- Prefer function components over class components
- Use CSS modules for component-specific styles

Performance:
- Minimize 'use client' directives
- Favor React Server Components
- Wrap client components in Suspense with fallback
- Use dynamic loading for non-critical components
- Optimize images with next/image

Architecture:
- Use the repository pattern for data access
- Implement clean architecture with clear separation of concerns
- Keep components under 150 lines
- Extract complex logic to custom hooks
```

Your patterns, applied consistently, without repeating instructions every prompt.

## @Docs Feature

Cursor's @Docs lets you integrate external documentation directly into AI interactions. No more tab-switching for reference material.

Provide a documentation link, Cursor indexes it, reference it with @Doc or the document name in prompts.

**Setup:**

1. Type @ in Chat or Composer, select "Docs," enter URL, name it (e.g., "TensorFlow")
2. Reference with @Name syntax: "Implement a custom loss function using @TensorFlow documentation"
3. Manage under Settings > Features > Docs. Auto re-indexes as docs change.

Built-in docs for popular libraries via @LibraryName (@React, @Python). Extend with specialized libraries, version-specific docs, internal API docs.

## Agent Mode

Cursor Agent mode (`cmd + I` or dropdown) is the most powerful feature. It loops Claude until the goal is achieved: searching files, gathering context, running tests, installing packages.

For maximum efficiency:

- Enable "Yolo mode" in settings. Cursor runs tests without confirmation prompts.
- Create new agent windows periodically. Long conversations cause Claude to forget earlier instructions.
- Use "think hard" to trigger extended thinking on complex problems.

## Claude Code: Command Line

Claude Code brings similar capabilities to the terminal. It understands project context and takes real actions. No manual file context needed.

Graduated thinking triggers allocate more thinking budget, letting Claude evaluate alternatives before acting.

For long sessions, use `/clear` frequently between tasks. Context windows get cluttered with irrelevant conversation, file contents, commands.

## What I Built With This

These tools powered most of my recent projects:

**[AI Data Extraction](https://github.com/0xSero/ai-data-extraction)** (121 stars): Extract personal data from Cursor, Codex, Claude Code, Windsurf, Trae. Built the core extraction logic manually, used AI for file parsing and edge cases.

**[Open Orchestra](https://github.com/0xSero/open-orchestra)** (96 stars): Multi-agent coordination. Designed the architecture myself, let AI handle boilerplate and tests.

**[Azul](https://github.com/0xSero/Azul)** (68 stars): Terminal web browser with AI. Manual design for the browser core, AI for rendering and interface polish.

**[mem-layer](https://github.com/0xSero/mem-layer)** (55 stars): Graph database memory organization for AI. Manually designed the graph structure, AI generated CRUD operations.

**[minimax-m2-proxy](https://github.com/0xSero/minimax-m2-proxy)** (33 stars): Proxy enabling interleaved thinking and tool calls. Critical protocol logic done by hand, AI handled HTTP scaffolding.

**[codex-local](https://github.com/0xSero/codex-local)** (29 stars): Modified Codex CLI for local LLMs. Forked and modified manually, AI helped with configuration options.

The pattern: design the hard parts yourself, let AI handle the repetitive stuff.

## Architecture Patterns That Work

Certain patterns work exceptionally well with AI:

**Reflection Pattern:** AI generates a solution, then reviews and critiques its own code, refining based on self-evaluation.

**Tool Use Pattern:** AI interacts with external tools. Databases, web searches, function execution.

**Planning Pattern:** AI creates a detailed plan before implementation. Provide feedback before coding starts.

**Multiagent Pattern:** Use "subagents" to verify details or investigate questions while preserving main context.

More autonomous assistance, higher quality results.

## TDD with AI

AI excels at generating tests. TDD becomes powerful:

1. AI generates test cases for your feature
2. Implement the tests
3. AI writes code that passes the tests
4. Integrate and run tests
5. AI fixes failing tests
6. Finalize

Claude Code is especially effective for TDD, debugging complex issues, large-scale refactoring.

## Project Structure

Organize files for AI comprehension:

- Include PRD (Product Requirements Document) as Markdown in the repo
- Clear, descriptive file and directory names
- Keep related files close in directory structure
- Use `.cursorignore` for large files AI should skip

## Preserving Your Skills

Valid concern: skill atrophy from AI tools. My approach:

**Manual coding sessions:** Dedicated time without AI. Focus on algorithms, data structures, system design.

**Core functionality by hand:** Security, performance, business logic. Written by you.

**Review everything:** Understand every line before accepting. Ask AI to explain complex sections. Modify manually to ensure understanding.

**Regular challenges:** Solve coding problems without AI periodically.

**Track progress:** Baseline your skills, identify areas for improvement, create practice plans.

## Workflow by Project Type

### Frontend Development

- Manually design component hierarchy
- AI generates project scaffold
- AI handles boilerplate components
- Manual effort on complex interactions and state
- Manually design API integrations, AI implements calls
- AI generates test cases, manually add edge cases

### Backend API Development

- Manually design data models and relationships
- AI generates OpenAPI/Swagger specs
- Alternate between AI-generated code and manual implementation
- Manually implement validation logic, AI generates tests
- AI generates comprehensive API documentation

### Refactoring

- Claude Code excels here
- Point it at legacy code, describe target architecture
- Review changes carefully before committing

## The Balance

As these tools evolve, successful developers will balance AI assistance with human judgment. AI enhances capabilities. It doesn't replace them.

Design the architecture. Understand the code. Let AI handle the tedious parts. Ship faster without becoming dependent.
